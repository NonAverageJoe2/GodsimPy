from __future__ import annotations

"""Civilization seeding utilities.

This module provides helpers for scoring tiles, selecting starting
positions, and initializing civilization metadata within the world
state. Only lightweight metadata is stored here; tile ownership and
population live in :class:`~sim.state.WorldState` maps.
"""

from dataclasses import dataclass, field
from typing import List, Tuple, Optional

import colorsys
import numpy as np
from numpy.typing import NDArray

from sim.state import WorldState
from sim.resources import biome_yields
from society import SocietyType, DEFAULT_SOCIETY, SocietyModifiers


# ---------------------------------------------------------------------------
# Dataclass representing civilization metadata
# ---------------------------------------------------------------------------


@dataclass
class Civilization:
    """Metadata for a civilization.

    Parameters
    ----------
    id:
        Sequential civilization identifier.
    name:
        Human readable civilization name.
    color:
        RGB tuple used for map rendering.
    rng_seed:
        Deterministic random seed for this civilization. Only metadata is
        stored here; map state is contained in :class:`WorldState`.
    capital:
        Coordinates (r, c) of the civilization's capital city.
    culture_id:
        ID of the culture this civilization belongs to.
    religion_id:
        ID of the religion this civilization follows.
    """

    id: int
    name: str
    color: Tuple[int, int, int]
    rng_seed: int
    capital: Optional[Tuple[int, int]] = None
    culture_id: int = -1
    religion_id: int = -1
    society_type: SocietyType = SocietyType.HUNTER_GATHERER
    _society_mods: SocietyModifiers = field(init=False)

    def __post_init__(self) -> None:
        # Bind modifiers according to the initial society type
        self._society_mods = DEFAULT_SOCIETY[self.society_type]

    def set_society(self, st: SocietyType) -> None:
        """Apply a new society type to this civilization."""

        self.society_type = st
        self._society_mods = DEFAULT_SOCIETY[st]

    # ------------------------------------------------------------------
    # Persistence helpers
    # ------------------------------------------------------------------

    def to_dict(self) -> dict:
        """Serialize civilization metadata to a plain dictionary."""

        data = self.__dict__.copy()
        data["society_type"] = self.society_type.name
        data.pop("_society_mods", None)
        return data

    @classmethod
    def from_dict(cls, data: dict) -> "Civilization":
        """Deserialize from :meth:`to_dict` output."""

        st_name = data.pop("society_type", "HUNTER_GATHERER")
        civ = cls(**data)
        try:
            civ.set_society(SocietyType[st_name])
        except KeyError:
            civ.set_society(SocietyType.HUNTER_GATHERER)
        return civ


# ---------------------------------------------------------------------------
# Palette and scoring helpers
# ---------------------------------------------------------------------------


def make_palette(n: int) -> List[Tuple[int, int, int]]:
    """Return a deterministic list of ``n`` distinct RGB colors.

    Colors are generated by evenly spacing hues in HSV space and converting
    them to RGB. The palette length is always exactly ``n``.
    """

    if n < 0:
        raise ValueError("n must be >= 0")
    palette: List[Tuple[int, int, int]] = []
    for i in range(n):
        h = i / max(n, 1)
        r, g, b = colorsys.hsv_to_rgb(h, 0.7, 0.9)
        palette.append((int(r * 255), int(g * 255), int(b * 255)))
    return palette


def score_tiles(food: NDArray[np.float32],
                prod: NDArray[np.float32]) -> NDArray[np.float32]:
    """Compute a simple food/production score for each tile.

    ``score = food + 0.2 * prod``. Inputs must be 2D arrays of matching
    shape and finite values. The result is a contiguous ``float32`` array.
    """

    f_arr = np.asarray(food)
    p_arr = np.asarray(prod)
    if f_arr.ndim != 2 or p_arr.ndim != 2:
        raise ValueError("food and prod must be 2D arrays")
    if f_arr.shape != p_arr.shape:
        raise ValueError("food and prod must have matching shapes")
    if not (np.isfinite(f_arr).all() and np.isfinite(p_arr).all()):
        raise ValueError("food/prod contain NaN or Inf")

    score = np.ascontiguousarray(
        f_arr.astype(np.float32, copy=False) +
        np.float32(0.2) * p_arr.astype(np.float32, copy=False),
        dtype=np.float32,
    )
    return score


# ---------------------------------------------------------------------------
# Land mask helper
# ---------------------------------------------------------------------------


def _valid_land_mask(biome: np.ndarray) -> np.ndarray:
    """Return mask of tiles that are valid land (not ocean or mountain)."""

    b_arr = np.asarray(biome)
    if b_arr.ndim != 2:
        raise ValueError("biome must be 2D")
    if not np.isfinite(b_arr).all():
        raise ValueError("biome contains NaN or Inf")
    b = b_arr.astype(np.int64, copy=False)
    mask = (b != 3) & (b != 2)
    return mask


# ---------------------------------------------------------------------------
# Start position selection
# ---------------------------------------------------------------------------


def pick_start_positions(
    biome: np.ndarray,
    food: np.ndarray,
    n: int,
    *,
    min_distance: int = 3,
    seed: int = 0,
) -> List[Tuple[int, int]]:
    """Pick ``n`` starting positions on valid land tiles.

    The function scores tiles by food yield, ranks them, and greedily selects
    positions that satisfy a minimum Chebyshev distance between already chosen
    tiles. If insufficient positions are found with the requested spacing, the
    distance requirement is relaxed stepwise down to zero. A ``ValueError`` is
    raised if fewer than ``n`` positions can be selected even with zero
    spacing.
    """

    if n < 0:
        raise ValueError("n must be >= 0")
    if min_distance < 0:
        raise ValueError("min_distance must be >= 0")

    b_arr = np.asarray(biome)
    f_arr = np.asarray(food)
    if b_arr.shape != f_arr.shape:
        raise ValueError("biome and food must have the same shape")
    if b_arr.ndim != 2:
        raise ValueError("biome and food must be 2D")
    if not (np.isfinite(b_arr).all() and np.isfinite(f_arr).all()):
        raise ValueError("biome/food contain NaN or Inf")

    mask = _valid_land_mask(b_arr)
    rows, cols = np.nonzero(mask)
    if rows.size < n:
        raise ValueError("Not enough land for n start positions")

    rng = np.random.default_rng(seed)
    scores = f_arr.astype(np.float32, copy=False)[mask]
    scores = scores + rng.uniform(0.0, 1e-9, size=scores.shape)
    order = np.argsort(scores)[::-1]
    cand_rows = rows[order]
    cand_cols = cols[order]
    candidates = list(zip(cand_rows.tolist(), cand_cols.tolist()))

    # Try decreasing spacing until enough positions are found
    for dist in range(min_distance, -1, -1):
        chosen: List[Tuple[int, int]] = []
        for r, c in candidates:
            if all(max(abs(r - cr), abs(c - cc)) >= dist for cr, cc in chosen):
                chosen.append((int(r), int(c)))
                if len(chosen) == n:
                    return chosen
    raise ValueError("Not enough land for n start positions")


# ---------------------------------------------------------------------------
# Civilization initialization
# ---------------------------------------------------------------------------


def initialize_civs(
    ws: WorldState,
    n_civs: int,
    base_pop: float = 40.0,
    seed: int = 0,
    cultures: Optional[List] = None,
    religions: Optional[List] = None,
) -> Tuple[WorldState, List[Civilization]]:
    """Initialize ``n_civs`` civilizations in ``ws``.

    Ownership and population maps in ``ws`` are updated in-place. A list of
    :class:`Civilization` metadata objects is returned alongside the modified
    world state.
    """

    if n_civs < 0:
        raise ValueError("n_civs must be >= 0")
    if ws.owner_map.dtype != np.int32 or not ws.owner_map.flags["C_CONTIGUOUS"]:
        raise ValueError("owner_map must be int32 and C-contiguous")
    if ws.pop_map.dtype != np.float32 or not ws.pop_map.flags["C_CONTIGUOUS"]:
        raise ValueError("pop_map must be float32 and C-contiguous")

    yields = biome_yields(ws.biome_map)
    food = yields["food"]

    positions = pick_start_positions(
        ws.biome_map,
        food,
        n_civs,
        min_distance=3,
        seed=seed,
    )

    colors = make_palette(n_civs)
    civs: List[Civilization] = []
    for i, (r, c) in enumerate(positions):
        ws.owner_map[r, c] = np.int32(i)
        # Add base_pop to any existing population (from seeding)
        current_pop = float(ws.pop_map[r, c])
        ws.pop_map[r, c] = np.float32(base_pop + current_pop)
        ws.settlement_map[r, c] = np.uint8(4)  # Mark as capital (4)
        
        # Assign culture and religion based on location
        culture_id = -1
        religion_id = -1
        
        if hasattr(ws, 'culture_map') and ws.culture_map is not None:
            culture_id = int(ws.culture_map[r, c])
        
        if hasattr(ws, 'religion_map') and ws.religion_map is not None:
            religion_id = int(ws.religion_map[r, c])
        
        # Assign civ to the culture at their spawn location
        culture_linguistic_type = "latin"  # Default fallback
        
        if hasattr(ws, 'culture_map') and ws.culture_map is not None and culture_id >= 0:
            # Get the linguistic type from cultures if available
            if cultures and culture_id < len(cultures):
                culture = cultures[culture_id]
                if hasattr(culture, 'linguistic_type'):
                    culture_linguistic_type = culture.linguistic_type
        
        # Generate civilization name using culture's linguistic type
        try:
            import sys
            import os
            sys.path.append(os.path.dirname(os.path.dirname(__file__)))
            from name_generator import NameGenerator
            name_gen = NameGenerator(seed + i * 1000)
            name = name_gen.generate_country_name(style=culture_linguistic_type)
        except ImportError:
            # Fallback to simple naming if name generator not available
            if i < 26:
                name = f"Civ {chr(65 + i)}"
            else:
                name = f"Civ {i}"
        
        rng_seed = seed ^ (i * 9973 + 12345)
        civs.append(Civilization(
            id=i, 
            name=name, 
            color=colors[i], 
            rng_seed=int(rng_seed), 
            capital=(r, c),
            culture_id=culture_id,
            religion_id=religion_id
        ))

    return ws, civs

